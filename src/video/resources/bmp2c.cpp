//----------------------------------------------------------------------------
// File:	bmp2c.cpp
// Author:	Tony Saveski
// Notes:	Converts a 24-bit BMP file into C code for a 'compiled bitmap'.
//----------------------------------------------------------------------------
#include "../defines.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//----------------------------------------------------------------------------
#ifdef WIN32
#pragma pack(push)
#pragma pack(1)
#endif

typedef struct
{
	char	sig[2];			// 'BM'
	uint32	file_size;		// File size in bytes
	uint32	reserved;		// unused (=0)
	uint32	data_offset;	// File offset to Raster Data
} bmp_header_t;

typedef struct
{
	uint32 size;			// Size of InfoHeader = 40
	uint32 width;			// Bitmap Width
	uint32 height;			// Bitmap Height
	uint16 planes;			// Number of Planes = 1
	uint16 bpp;				// Bits per Pixel = 24
	uint32 comp;			// Type of Compression = 0
	uint32 image_size;		// (compressed) Size of Image
	uint32 x_pixels_per_m;	// horizontal resolution: Pixels/meter
	uint32 y_pixels_per_m;	// vertical resolution: Pixels/meter
	uint32 colors_used;		// Number of actually used colors
	uint32 colors_important;// Number of important colors
} bmp_iheader_t;

#ifdef WIN32
#pragma pack(pop)
#endif

//----------------------------------------------------------------------------
static bmp_header_t		bmp_h;
static bmp_iheader_t	bmp_ih;

//----------------------------------------------------------------------------
void usage(void)
{
	fprintf(stderr, "\n");
	fprintf(stderr, "usage: bmp2c <bmp file> <c name>\n");
	exit(1);
}

//----------------------------------------------------------------------------
int main(int argc, char **argv)
{
char	filename[512], varname[256];
FILE	*fh=NULL;
uint16	w, h;
uint16	line_len;
uint8	*line=NULL, *p=NULL;
uint16	i, j;
uint32	out;

	if(argc != 3) usage();

	strcpy(filename, argv[1]);
	strcpy(varname, argv[2]);

	fh = fopen(argv[1], "rb");
	if(!fh)
	{
		fprintf(stderr, "ERROR: failed to load file:'%s'\n", filename);
		goto err_bmp2c;
	}

	if(!fread(&bmp_h, sizeof(bmp_header_t), 1, fh))
	{
		fprintf(stderr, "ERROR: failed to read bmp_header_t structure from file:'%s'\n", filename);
		goto err_bmp2c;
	}

	if(!fread(&bmp_ih, sizeof(bmp_iheader_t), 1, fh))
	{
		fprintf(stderr, "ERROR: failed to read bmp_iheader_t structure from file:'%s'\n", filename);
		goto err_bmp2c;
	}
/*
fprintf(stderr, "%c%c\n", bmp_h.sig[0], bmp_h.sig[1]);
fprintf(stderr, "bmp_ih.size=%d\n", bmp_ih.size);
fprintf(stderr, "bmp_ih.planes=%d\n", bmp_ih.planes);
fprintf(stderr, "bmp_ih.bpp=%d\n", bmp_ih.bpp);
fprintf(stderr, "bmp_ih.comp=%d\n", bmp_ih.comp);
fprintf(stderr, "bmp_ih.width=%d\n", bmp_ih.width);
fprintf(stderr, "bmp_ih.height=%d\n", bmp_ih.height);
fprintf(stderr, "bmp_h.data_offset=0x%x\n", bmp_h.data_offset);
*/
	if( (bmp_h.sig[0]  != 'B') ||
		(bmp_h.sig[1]  != 'M') ||
		(bmp_ih.size   != 40)  ||
		(bmp_ih.planes != 1)   ||
		(bmp_ih.bpp    != 24)  ||
		(bmp_ih.comp   != 0))
	{
		fprintf(stderr, "ERROR: only valid 24-bit BMP files are supported by this tool\n");
		goto err_bmp2c;
	}

	w = bmp_ih.width;
	h = bmp_ih.height;
	line_len = w*3;

	line = (uint8 *)malloc(line_len);
	if(!line) goto err_bmp2c;

	// TODO: check that w and h are powers of 2 and adjust if needed
	fprintf(stdout, "// File Generated by BMP2C from %s\n", filename);
	fprintf(stdout, "#include \"defines.h\"\n\n");
	fprintf(stdout, "uint32 %s_w = %d;\n", varname, w);
	fprintf(stdout, "uint32 %s_h = %d;\n", varname, h);
	fprintf(stdout, "\n");
	fprintf(stdout, "uint32 __attribute__((aligned(16))) %s[] = {\n", varname);

	// Read rows in reverse order and print code to stdout
	for(i=0; i<h; i++)
	{
		if(fseek(fh, bmp_h.data_offset+((h-i-1)*line_len), SEEK_SET))
		{
			fprintf(stderr, "ERROR: failed to seek to row %d of image data in file:'%s'\n", i, filename);
			goto err_bmp2c;
		}

		if(!fread(line, line_len, 1, fh))
		{
			fprintf(stderr, "ERROR: failed to read row %d of image data in file:'%s'\n", i, filename);
			goto err_bmp2c;
		}

		fprintf(stdout, "\t// row %d\n", i);
		p = line; // p[0]=B, p[1]=G, p[2]=R
		for(j=0; j<w; j++, p+=3)
		{
			out = ((uint32)(p[0]) << 16) | ((uint32)(p[1]) << 8) | ((uint32)(p[2]));
			if(out==0)
				fprintf(stdout, "\t0x00%06x,\n", out);
			else
				fprintf(stdout, "\t0x80%06x,\n", out);
		}
	}
	fprintf(stdout, "};\n");

	free(line);
	fclose(fh);
	return(0);

err_bmp2c:
	if(line) free(line);
	if(fh)   fclose(fh);
	return(1);
}

